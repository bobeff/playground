# Съвпадения

<img src="http://www.ymeme.com/files/images/lisp_cycles.png" />

Скобите са нашите елегантни оръжия, а макросите - тайното изкуство, с което
можем да овладеем безпределната им сила.

Както споменахме на лекции, нещо присъщо за Lisp диалектите е малкото
ядро. В Clojure има по-малко от 20 специални форми, чрез които, в
комбинация с макросите, са имплементирани всички останали синтактични
конструкции. Макросите ни дават силата да трансформираме произволна структура от
данни, в най-обикновен Clojure код, който може да бъде изпълняван. Това ни
позволява да си измислим и имплементираме достатъчно прост и експресивен
синтаксис за описание на разнообразие от проблеми без да нужно да правим каквито
и да било промени по компилатора.

# Пример

[Инж. Донев](http://www.vbox7.com/play:cccdb600) е измислил новата си игра, в
която всеки от участниците хвърля 3 зарчета и в зависимост от това какво се е
паднало, на всяко от тях, играчът печели определен брой точки. Правилата,
отлично преценени и балансирани от Донев, гласят следното:

- Ако играч хвърли три шестици той не печели никакви точки.
- Ако на първите два зара се паднат съответно 4 и 6, точките на играча се умножават по -1.
- Ако на първия зар се падне 3, а на последния 1, играчът автоматично губи.
- Печели играчът, който има най-много точки след 10 хвърляния от хвърлянето,
  при което друг играч е направил 17 точки, след като на масата...

Можем да реализираме част от логиката на Донев по следния начин:

```
(let [result [3 6 1]]
  (cond
   (= result [6 6 6])
   "0 points"

   (and (= 4 (first result))
        (= 6 (second result)))
   "1 point"

   (and (= 3 (first result))
        (= 1 (last result)))
   "you lose"))
```
... но така за разлика от проблема, решението няма да е особено елегантно. За
това ще упражним малко уменията си да пишем макроси и ще сведем решението до
следните елегантни 4 реда:

```
(match [3 6 1]
  [6 6 6] "0 points"
  [4 6 _] "1 point"
  [3 _ 1] "you loose")
```

# Задача (Pattern matching)

Реализирайте макроса `match`, който приема израз и поредица от двойки. Първия
елемент на всяка двойка е шаблон, а втория е форма, която ще се изпълни ако
първоначално подадения израз съвпадне с шаблона. Първоначалния израз се
съпоставя последователно на шаблоните. Когато бъде намерен шаблон, съпоставянето
спира, израза на шаблона се изпълнява и се връща получената стойност.

* Всички шаблони след съвпадението не се оценяват.
* Оценява се само формата след съвпаденалия шаблон.
* Ако никой от шаблоните не пасва, `match` връща `nil`.
* Съвпадението работи само на едно ниво. (не можем да влагаме)

Първоначалният израз и шаблоните трябва да бъдат последователности. Ако
такива не са подадени, подаденото трябва да се третира като последователност с
един елемент.

```clojure
(match 2
  1 :one
  2 :two
  3 :three) ; :two

;; еквивалентно на горното
(match [2]
  [1] :one
  [2] :two
  [3] :three) ; :two

(match [1 2]
  [1 2] (* 3 2)
  [2 3] (prn "it is [2 3]")
  [3 4] :woooow) ; 6
```

В шаблоните имаме няколко специални ключови думи, които съвпадат на определен тип:

* `:fn`   - функция
* `:int`  - integer
* `:seq`  - последователност
* `:odd`  - нечетно число
* `:str`  - низ
* `:even` - четно число

```clojure
(match [["m"]] :seq "yes")                ; yes
(match ["m" "a" "p"] :seq "yes")          ; nil (:seq става [:seq])
(match [["m" "a" "p"] []] [:seq :seq] "yes") ; yes
(match [map 1] [:fn :int] "yes")          ; yes
(match ["map" 1] [:str :int] "yes")       ; yes
```

`_` съвпада с нещо от произволен тип:

```clojure
(match ["map" 1] [_ _] "yes") ; yes
(match ["map" 1] _ "yes")     ; nil  (_ става [_])
```

`:or` съвпада с всеки един аргументите си. В `:or` не можем да използваме
специални символи:

```clojure
(match 2 (:or 1 (inc 1) (+ 1 2)) "1, 2 or 3") ; "1, 2 or 3"
```

## Комплексен пример

```clojure
(match [1 (inc 1) 3]
  [4 _ :int]               false
  [1 (+ 2 0) (:or 4 3 19)] true
  ["a" "b" "c"]            false
  ["c" (prn 10) []]        false)
```

## Бонус

В изразите, с които ще тестваме, както и във формите след шаблоните няма да има
ключови думи или символи. Оставяме на вас да разширите задачата с допълнителна
функционалност, което ще ви носи бонус точки. Ето няколко идеи:

* Влагане на шаблоните
* Шаблони за мапове
* Даване на имена на мачнати стойности
* Pattern matching вариант на `defn`
* `[& rest]` шаблони

## Бележки

* Използвайте различните варианти на macroexpand.
* Ползвайте минимален брой макрости и изнасяйте максимално много от логиката във функции.
* Може да използвате каквито модули си харесате в стандартната библиотека.
* [Clojure cheatsheet][cheatsheet] е ваш приятел.
* **Пуснете си примерния тест**. Целта му е да провери, че системата ни за
  проверка се справя с вашето решение. Ако има грешка при неговото изпълнение,
  ще има грешка и при проверката, в резултат на което е вероятно да имате 0
  точки.

[cheatsheet]: http://clojure.org/cheatsheet
